# SPDX-FileCopyrightText: 2020 - 2024 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0

"""
The numba-dpex extension module adds data-parallel offload support to Numba.
"""
import glob
import logging
import os
import platform as plt
import re
from typing import Tuple

import dpctl
import llvmlite.binding as ll
from numba import __version__ as numba_version

from .kernel_api_impl.spirv import target as spirv_kernel_target
from .numba_patches import patch_ufuncs
from .register_kernel_api_overloads import init_kernel_api_spirv_overloads


def load_dpctl_sycl_interface():
    """Permanently loads the ``DPCTLSyclInterface`` library provided by dpctl.
    The ``DPCTLSyclInterface`` library provides C wrappers over SYCL functions
    that are directly invoked from the LLVM modules generated by numba_dpex.
    We load the library once at the time of initialization using llvmlite's
    load_library_permanently function.
    Raises:
        ImportError: If the ``DPCTLSyclInterface`` library could not be loaded.
    """

    platform = plt.system()
    if platform == "Windows":
        paths = glob.glob(
            os.path.join(
                os.path.dirname(dpctl.__file__), "*DPCTLSyclInterface.dll"
            )
        )
    else:
        paths = glob.glob(
            os.path.join(
                os.path.dirname(dpctl.__file__), "*DPCTLSyclInterface.so.0"
            )
        )

    if len(paths) == 1:
        ll.load_library_permanently(paths[0])
    else:
        raise ImportError


def parse_sem_version(version_string: str) -> Tuple[int, int, int]:
    """Parse sem version into tuple of three integers. If there is a suffix like
    rc1, dev0 - it will be ignored."""
    return tuple(
        map(
            int,
            re.sub(
                "([0-9]+\\.[0-9]+\\.[0-9]+).*",
                "\\g<1>",
                version_string,
            ).split(".")[:3],
        )
    )


numba_sem_version = parse_sem_version(numba_version)
dpctl_sem_version = parse_sem_version(dpctl.__version__)

# Monkey patches
patch_ufuncs.patch()

from numba import prange  # noqa E402

import numba_dpex.core.dpjit_dispatcher  # noqa E402

# Initialize the _dpexrt_python extension
import numba_dpex.core.runtime  # noqa E402
import numba_dpex.core.targets.dpjit_target  # noqa E402

# Re-export types itself
import numba_dpex.core.types as types  # noqa E402
from numba_dpex.core import boxing  # noqa E402
from numba_dpex.core import config  # noqa E402
from numba_dpex.core.overloads import ranges_overloads  # noqa E402

# Re-export all type names
from numba_dpex.core.types import *  # noqa E402
from numba_dpex.dpctl_iface import _intrinsic  # noqa E402
from numba_dpex.dpnp_iface import dpnpimpl  # noqa E402

# Importing NdRange and Range into numba_dpex for
# backward compatibility
from numba_dpex.kernel_api import NdRange, Range  # noqa E402

from .core.decorators import device_func, dpjit, kernel  # noqa E402
from .core.kernel_launcher import call_kernel, call_kernel_async  # noqa E402
from .core.targets import dpjit_target  # noqa E402

load_dpctl_sycl_interface()
del load_dpctl_sycl_interface


from numba_dpex._version import get_versions  # noqa E402

__version__ = get_versions()["version"]
del get_versions

# Initialize the kernel_api SPIRV overloads
init_kernel_api_spirv_overloads()

__all__ = types.__all__ + [
    "call_kernel",
    "call_kernel_async",
    "device_func",
    "dpjit",
    "kernel",
    "prange",
    "Range",
    "NdRange",
]
